import sys
import math
import time
import random
import concurrent.futures
from sympy import isprime

sys.set_int_max_str_digits(999999999)
# 2 ** 1024 then pick odd that's slightly smaller?
BIT_1024_INT =  179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137211

# Sample numbers
A_LARGE_USELESS_INT = sys.maxsize // 69696696969699
mersenne_primes = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583, 25964951, 30402457]
not_merseene = [69, 69696696969699, A_LARGE_USELESS_INT]

# Test from sympy import isprime
for _ in mersenne_primes:
    print(f"is {_} Is this Merseene number primes? {isprime(_)}")
for n in not_merseene:
    print(f"is {n} Is this non-prime prime? {isprime(n)}")

# class EllipticCurve:
#     """
#     Simple representation of an elliptic curve.
#     y^2 = x^3 + ax + b over finite field of prime p.
#     """
#     def __init__(self, a, b, p):
#         self.a = a
#         self.b = b
#         self.p = p

#         self.discriminant = -16 * (4 * a**3 + 27 * b**2)
#         if self.discriminant == 0:
#             raise ValueError("The curve {} is not smooth!".format(self))

#     def is_on_curve(self, point):
#         if point is None:
#             # None represents the point at infinity.
#             return True

#         x, y = point
#         return (y**2 - x**3 - self.a * x - self.b) % self.p == 0

#     def add_points(self, point1, point2):
#         if point1 is None:
#             # None represents the point at infinity.
#             return point2
#         if point2 is None:
#             return point1

#         x1, y1 = point1
#         x2, y2 = point2

#         if x1 == x2 and y1 != y2:
#             return None  # Point at infinity

#         if x1 == x2:
#             m = (3 * x1**2 + self.a) * pow(2 * y1, -1, self.p)
#         else:
#             m = (y2 - y1) * pow(x2 - x1, -1, self.p)

#         x3 = m**2 - x1 - x2
#         y3 = y1 + m * (x3 - x1)
#         result = (x3 % self.p, -y3 % self.p)

#         return result


# def is_prime(n): # Using elliptical curve cryptography
#     """
#     Simple primality test using elliptic curves.
#     """
#     print(f"n is {n}")
#     if n <= 1:
#         print("line 63")
#         return False

#     # Choose random elliptic curve parameters
#     a = random.randrange(0, n)
#     b = random.randrange(0, n)
#     curve = EllipticCurve(a, b, n)

#     # Choose a random point on the curve
#     x = random.randrange(0, n)
#     y = random.randrange(0, n)
#     point = (x, y)
#     if not curve.is_on_curve(point):
#         print("NOT PRIME; NOT ON CURVE")
#         return False
#     else:
#         print(f"PRIME!{n}")
#         sys.exit()

print("7 is prime?", isprime(7))

print("69 is prime?", isprime(69))

def binary_viewer_for_ints(number):
    binary_representation = bin(number)[2:]  # Convert the number to binary and remove the '0b' prefix
    return binary_representation


def thread_prime(list_of_int_crap, max_threads=1000):
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
        futures = [executor.submit(isprime, cra and print(f"Prime False! {cra}") if not isprime(cra) else print(f"Prime True! {cra}")) for cra in list_of_int_crap]
        concurrent.futures.wait(futures)

# Example usage:
number = 2**8191-1
another_number = 2 ** 8000
binary_representation = binary_viewer_for_ints(number)
# binary_another = binary_viewer_for_ints(another_number)
# new_binary = binary_representation - binary_another
len_binary = len(binary_representation)
rand_digit = random.randint(2, len_binary - 1)
#binary_representation[rand_digit] = "0"
list_of_crap = [*range(2, len_binary - 1)]
rand_list_of_crap = sorted(list_of_crap, key=lambda x: random.random())
#print(rand_list_of_crap)

int_from_crap = int(binary_representation, 2)
list_of_int_crap = []

#print(int_from_crap, 'line 156')
for poop in range(1000000, 2000000):
    list_of_int_crap.append(int_from_crap - poop*2)
#print(list_of_int_crap)

# thread_prime(list_of_int_crap)

crap_list = []

def get_list_of_crap(binary_representation):
    for c in binary_representation:
        crap_list.append(c)

get_list_of_crap(binary_representation=binary_representation)

def thread_crap(crap_list, max_threads=1000):
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
        futures = [executor.submit(from_list_of_crap, cra) for cra in crap_list]
        concurrent.futures.wait(futures)

def from_list_of_crap(crap_list):
    
    new_binary_str = ""
    rand_int = random.randint(2, len(crap_list) - 2)
    rand_int2 = random.randint(2, len(crap_list) - 2)
    for idx, char in enumerate(crap_list):
        if idx == rand_int or idx == rand_int2:
            new_binary_str += "0"
        else:
            new_binary_str += "1"

    int_10 = int(new_binary_str, 2)
    print("int_10 is", int_10, "is prime???")
    if isprime(int_10) == False:
        print("FALSE")
    else:
        print("True lol", int_10)
        sys.exit()

# for _ in range(1000):
#     #thread_crap(crap_list) # no lock on reused new_binary_str etc.
#     from_list_of_crap(crap_list)

#thread_crap(crap_list)

#print(f"The binary representation of {new_base10} \n \nis: \n{binary_representation}")

def utf8_to_binary(text):
    binary_representation = ''
    # Encode the text to UTF-8
    utf8_encoded_text = text.encode('utf-8')
    
    # Convert each byte to its binary representation
    for byte in utf8_encoded_text:
        binary_representation += format(byte, '08b') + ' ' # 08b for 8-bit binary

    return binary_representation.strip()

cyndaquils = ["SimpForSam", "SimpforSam", "Samantha Briasco-Stewart", "Cyndaquil", "weewow", "Samantha"]
#cyndaquil = "Samantha Briasco-Stewart"
for cyndaquil in cyndaquils:
    binary_cyndaquil = utf8_to_binary(cyndaquil)
    print(f"\nThe length of {cyndaquil} is {len(cyndaquil)} and {cyndaquil} in UTF-8 in binary is", binary_cyndaquil)

print("\n")

def view_binary_file(file_path):
    try:
        with open(file_path, 'rb') as file:
            while True:
                byte = file.read(1)
                if not byte:
                    break
                print("WTH is this", byte, end='  🤔 🤔 🤔 😘   ')
                print("This encoding on this line in hex is", byte.hex(), end='\n')
                
    except FileNotFoundError:
        print(f"The file '{file_path}' was not found.")
    except Exception as e:
        print(f"An error occurred: {e}")

def write_binary_file(file_path):
    pass

def inject_binary_file(file_path):
    pass

len_of_M82589933 = len("商博")
# print(len("商博")) # this is so basic

print(f"\nThe length of M82589933 is {len_of_M82589933} and M82589933 is not able to encrypt this any futher unless you provide M82589933 with a public key 😘")
GhidraM82589933 = utf8_to_binary("商博")
print(f"\nwith love,\n{GhidraM82589933}")

#M82589933 = ["1"*82589933]
#print(f"with love,\n{M82589933}")

if __name__ == "__main__":
    view_binary_file("A")
    print(utf8_to_binary("A"))
    print("\n")
    view_binary_file("商博")
    sys.exit()
    view_binary_file("test.bin")
    #sys.exit()
    view_binary_file("MicrosoftWordMacOS")